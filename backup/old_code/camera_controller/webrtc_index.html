<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CameraStreamer WebRTC</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 8px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 { color: #333; margin-top: 0; }
    video {
      width: 100%;
      max-width: 1280px;
      border: 2px solid #ccc;
      border-radius: 4px;
      background: #000;
    }
    .controls-section {
      margin: 16px 0;
      padding: 12px;
      background: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    .button-group { margin: 12px 0; }
    button {
      padding: 10px 20px;
      margin-right: 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #start { background: #4CAF50; color: white; }
    #start:hover:not(:disabled) { background: #45a049; }
    #stop { background: #f44336; color: white; }
    #stop:hover:not(:disabled) { background: #da190b; }
    #snapshot { background: #FF9800; color: white; }
    #snapshot:hover:not(:disabled) { background: #e68900; }
    #apply { background: #2196F3; color: white; }
    #apply:hover { background: #0b7dda; }
    #reset { background: #9E9E9E; color: white; }
    #reset:hover { background: #757575; }
    .form-group { margin: 8px 0; }
    .form-group label {
      display: inline-block;
      width: 100px;
      font-weight: bold;
    }
    select, input[type="range"], input[type="number"] {
      padding: 4px;
      margin-left: 8px;
    }
    .control-item {
      margin: 12px 0;
      padding: 8px;
      background: white;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .control-item label {
      min-width: 180px;
      font-weight: bold;
      font-size: 13px;
    }
    .control-item input[type="range"] {
      flex: 1;
      min-width: 200px;
    }
    .control-item .value-display {
      min-width: 60px;
      text-align: right;
      font-weight: bold;
      color: #2196F3;
    }
    .control-item select {
      flex: 1;
    }
    .control-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
    }
    .status-message {
      margin: 8px 0;
      padding: 8px;
      border-radius: 4px;
      display: none;
    }
    .status-message.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }
    .status-message.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }
    #controls-container {
      max-height: 600px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üìπ CameraStreamer WebRTC</h2>
    <p>Click Start to begin streaming. Press Ctrl+C in terminal to stop the server.</p>
    
    <div class="button-group">
      <button id="start">‚ñ∂ Start Stream</button>
      <button id="stop" disabled>‚èπ Stop Stream</button>
      <button id="snapshot" disabled>üì∑ Take Snapshot</button>
    </div>

    <div id="status" class="status-message"></div>

    <div class="controls-section">
      <h3>üìê Format Settings</h3>
      <div class="form-group">
        <label for="codec">Format:</label>
        <select id="codec"><option>MJPG</option></select>
      </div>
      <div class="form-group">
        <label for="resolution">Resolution:</label>
        <select id="resolution"><option>640x480</option></select>
      </div>
      <div class="form-group">
        <label for="fps">FPS:</label>
        <select id="fps"><option>30</option></select>
      </div>
    </div>

    <div class="controls-section">
      <h3>üéõÔ∏è Camera Controls</h3>
      <div id="controls-container">
        <p>Loading controls...</p>
      </div>
      <div class="button-group">
        <button id="apply">‚úì Apply Settings</button>
        <button id="reset">‚Ü∫ Reset to Defaults</button>
      </div>
    </div>

    <div><video id="video" autoplay playsinline></video></div>
  </div>

  <script>
    let pc = null;
    let videoEl = document.getElementById('video');
    let availableFormats = {};
    let availableControls = {};

    function showStatus(message, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = 'status-message ' + (isError ? 'error' : 'success');
      statusEl.style.display = 'block';
      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 3000);
    }

    // Create control UI element
    function createControlElement(name, control) {
      const div = document.createElement('div');
      div.className = 'control-item';
      div.dataset.controlName = name;
      
      const label = document.createElement('label');
      label.textContent = name.replace(/_/g, ' ');
      div.appendChild(label);
      
      if (control.type === 'bool') {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = 'ctrl_' + name;
        checkbox.checked = control.value === 1;
        div.appendChild(checkbox);
      } else if (control.type === 'menu' && control.menu) {
        const select = document.createElement('select');
        select.id = 'ctrl_' + name;
        for (const [value, label] of Object.entries(control.menu)) {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = label;
          if (parseInt(value) === control.value) {
            opt.selected = true;
          }
          select.appendChild(opt);
        }
        div.appendChild(select);
      } else {
        // Integer slider
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.id = 'ctrl_' + name;
        slider.min = control.min;
        slider.max = control.max;
        slider.step = control.step;
        slider.value = control.value;
        
        const valueDisplay = document.createElement('span');
        valueDisplay.className = 'value-display';
        valueDisplay.id = 'ctrl_' + name + '_value';
        valueDisplay.textContent = control.value;
        
        slider.oninput = () => {
          valueDisplay.textContent = slider.value;
        };
        
        div.appendChild(slider);
        div.appendChild(valueDisplay);
      }
      
      return div;
    }

    // Load available camera controls
    async function loadControls() {
      try {
        const resp = await fetch('/controls');
        availableControls = await resp.json();
        
        const container = document.getElementById('controls-container');
        container.innerHTML = '';
        
        if (Object.keys(availableControls).length === 0) {
          container.innerHTML = '<p>No controls available</p>';
          return;
        }
        
        // Create UI for each control
        for (const [name, control] of Object.entries(availableControls)) {
          const elem = createControlElement(name, control);
          container.appendChild(elem);
        }
        
      } catch (e) {
        console.warn('Failed to load controls:', e);
        document.getElementById('controls-container').innerHTML = 
          '<p style="color: red;">Failed to load controls: ' + e.message + '</p>';
      }
    }

    // Load available formats from server
    async function loadFormats() {
      try {
        const resp = await fetch('/formats');
        availableFormats = await resp.json();
        
        const codecEl = document.getElementById('codec');
        const resEl = document.getElementById('resolution');
        const fpsEl = document.getElementById('fps');
        
        // Populate codec dropdown
        codecEl.innerHTML = '';
        const codecs = Object.keys(availableFormats);
        codecs.forEach(codec => {
          const opt = document.createElement('option');
          opt.value = codec;
          opt.textContent = codec;
          if (codec === 'MJPG') opt.selected = true;
          codecEl.appendChild(opt);
        });
        
        // Update resolution/fps dropdowns when codec changes
        codecEl.onchange = updateResolutionFpsOptions;
        updateResolutionFpsOptions();
        
      } catch (e) {
        console.warn('Failed to load formats:', e);
      }
    }

    function updateResolutionFpsOptions() {
      const codec = document.getElementById('codec').value;
      const formats = availableFormats[codec] || [];
      
      // Get unique resolutions
      const resolutions = new Set();
      formats.forEach(f => {
        resolutions.add(`${f.width}x${f.height}`);
      });
      
      const resEl = document.getElementById('resolution');
      resEl.innerHTML = '';
      
      Array.from(resolutions).forEach(res => {
        const opt = document.createElement('option');
        opt.value = res;
        opt.textContent = res;
        if (res === '640x480') opt.selected = true;
        resEl.appendChild(opt);
      });
      
      resEl.onchange = updateFpsOptions;
      updateFpsOptions();
    }

    function updateFpsOptions() {
      const codec = document.getElementById('codec').value;
      const resValue = document.getElementById('resolution').value;
      const [width, height] = resValue.split('x').map(Number);
      
      const formats = availableFormats[codec] || [];
      const fpsOptions = formats
        .filter(f => f.width === width && f.height === height)
        .map(f => f.fps);
      
      const fpsEl = document.getElementById('fps');
      fpsEl.innerHTML = '';
      
      fpsOptions.forEach(fps => {
        const opt = document.createElement('option');
        opt.value = fps;
        opt.textContent = fps + ' fps';
        if (fps === 30.0) opt.selected = true;
        fpsEl.appendChild(opt);
      });
    }

    // Start streaming
    document.getElementById('start').onclick = async () => {
      document.getElementById('start').disabled = true;
      
      pc = new RTCPeerConnection();
      pc.ontrack = (evt) => {
        videoEl.srcObject = evt.streams[0];
        showStatus('Stream connected!');
      };

      pc.addTransceiver('video', { direction: 'recvonly' });

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      try {
        const resp = await fetch('/offer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type })
        });
        const answer = await resp.json();
        
        if (answer.error) {
          showStatus('Failed to start: ' + answer.error, true);
          document.getElementById('start').disabled = false;
          return;
        }
        
        await pc.setRemoteDescription(answer);
        document.getElementById('stop').disabled = false;
        document.getElementById('snapshot').disabled = false;
      } catch (e) {
        showStatus('Failed to start stream: ' + e.message, true);
        document.getElementById('start').disabled = false;
      }
    };

    // Stop streaming
    document.getElementById('stop').onclick = async () => {
      if (pc) {
        pc.close();
        pc = null;
      }
      videoEl.srcObject = null;
      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;
      document.getElementById('snapshot').disabled = true;
      showStatus('Stream stopped');
    };

    // Take snapshot
    document.getElementById('snapshot').onclick = async () => {
      try {
        const resp = await fetch('/snapshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const result = await resp.json();
        if (result.ok) {
          showStatus(`Snapshot saved: ${result.filename}`);
        } else {
          showStatus('Failed: ' + (result.error || 'Unknown error'), true);
        }
      } catch (e) {
        showStatus('Failed to take snapshot: ' + e.message, true);
      }
    };

    // Apply settings
    document.getElementById('apply').onclick = async () => {
      const resValue = document.getElementById('resolution').value;
      const [width, height] = resValue.split('x').map(Number);
      
      const body = {
        codec: document.getElementById('codec').value,
        width: width,
        height: height,
        fps: parseFloat(document.getElementById('fps').value)
      };
      
      // Add all control values
      for (const name of Object.keys(availableControls)) {
        const elem = document.getElementById('ctrl_' + name);
        if (!elem) continue;
        
        if (elem.type === 'checkbox') {
          body[name] = elem.checked ? 1 : 0;
        } else if (elem.tagName === 'SELECT') {
          body[name] = parseInt(elem.value);
        } else {
          body[name] = parseInt(elem.value);
        }
      }
      
      try {
        const resp = await fetch('/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const result = await resp.json();
        if (result.ok) {
          showStatus('Settings applied! Restart stream to use new resolution/codec.');
          // Reload controls to see updated values
          setTimeout(loadControls, 500);
        } else {
          showStatus('Failed to apply settings', true);
        }
      } catch (e) {
        showStatus('Failed: ' + e.message, true);
      }
    };

    // Reset to defaults
    document.getElementById('reset').onclick = async () => {
      for (const [name, control] of Object.entries(availableControls)) {
        const elem = document.getElementById('ctrl_' + name);
        if (!elem) continue;
        
        if (elem.type === 'checkbox') {
          elem.checked = control.default === 1;
        } else if (elem.tagName === 'SELECT') {
          elem.value = control.default;
        } else {
          elem.value = control.default;
          const valueDisplay = document.getElementById('ctrl_' + name + '_value');
          if (valueDisplay) {
            valueDisplay.textContent = control.default;
          }
        }
      }
      showStatus('Reset to default values. Click Apply to save.');
    };

    // Load formats and controls on page load
    loadFormats();
    loadControls();
  </script>
</body>
</html>
